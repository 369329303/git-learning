golang 语言部分

1. golang的内存管理？
2. golang的垃圾回收机制？
3. golang是如何调度Goroutine的？
4. golang是如何进行并发控制的？
5. golang中的slice类型介绍一下？共享和扩容？
6. golang中的defer关键字介绍一下？
7. golang中的互斥锁和读写锁有什么区别？
8. gRPC框架 是什么？
```
grpc是一个由Google开源的，高性能，支持多语言的RPC框架。基于HTTP/2协议设计，单TCP连接上多个双向Stream，头部压缩。
调用模型：
    1. 客户端调用方法A，发起RPC调用
    2. 对请求信息使用protobuf对数据进行序列化
    3. 服务端收到请求后，反序列化，获得请求，执行业务逻辑处理并返回应答
    4. 对应答信息使用protobuf再次序列化然后发给客户端
调用方式：
    1. 一元RPC
    2. 服务端流式RPC
    3. 客户端流式RPC
    4. 双向流式RPC
常见问题：
    1. grpc.Dial 是异步连接，状态为正在连接，但如果设置了grpc.WithBlock选项，就会阻塞等待。
    2. 调用ClientConn不Close会导致内存泄漏
    3. 如果不进行超时控制的化，短时间内不会有问题，但如果时间长了，就会造成内存泄漏
    4. 默认的拦截器可以传递多个，但是只有第一个有用。
    5. 频繁创建ClientConn会造成占用过多的文件句柄。
    6. 客户端请求失败会重试，直到上下文取消，重试时间采用backoff算法，最大重试时间为120s。
    7. gRPC的附加信息都会放在HEADERS帧中，数据放在DATA帧中
```
9. map实现顺序读取？
10. set实现一下？
11. golang中的逃逸分析是指什么？如何避免内存逃逸？



操作系统部分：
1. 死锁产生的条件及如何避免死锁？
2. 进程，线程，协程的区别？
3. LVS有哪几种模式？各有什么特点？
4. Keepalived介绍一下？

网络方面：
1. select, poll, epoll 之间的区别在哪里？
2. HTTP/1.1 于 HTTP/2 的区别？
```
    1. HTTP/1.1 是1999年提出的，HTTP/2 是2015年提出的。
    2. 影响HTTP网络请求的因素主要有两个，带宽和延迟。现在已经不是拨号上网的年待了，所以带宽不再是一个因素；延迟，DNS查询可以通过DNS缓存来解决。Head Of Line 阻塞，一个连接上无法跑多个请求都是问题。
    3. 多路复用：HTTP/1.1的pipeline机制虽然可以在一个TCP连接上跑多个请求，但是无法并发，容易产生HOL阻塞。而HTTP/2的多路复用是将请求分散，当作流来处理，每个请求对应不同的流，实现了请求的并发，并不会造成HOL阻塞。
    4. 首部压缩：HTTP/1.1的首部是不压缩的，并且多个请求通常都包含相同的首部。这对于带宽和延迟都很浪费。而HTTP/2通过在客户端和服务端分别维护一个动态字典和一个静态字典，用字符代替请求头来传输，降低带宽和延迟。
    5. 服务器推送：HTTP/1.1中客户端请求main.html，服务端仅返回main.html,但是HTTP/2会同时返回main.html, main.css等。这样客户端下次请求main.css的时候直接在缓存中就可以找到了。
    6. 可以传递二进制信息
```
3. TCP共有哪些状态？
```
    closed      listen
 
    syn_send   
                syn_recv
    established 
                established
           ========
    fin-wait-1
                close-wait
    fin-wait-2  
                last-ack
    time-wait    

    此外closing 状态比较少见，属于同时发送FIN包的情况。之后只要同时收到对方发来的ACK包，就可以进入time-wait状态.
```

4. TCP握手和挥手的过程说一下？
```
    握手过程：
    ->    syn(SYN=x)
    <-    syn+ack(SYN=y, ACK=x+1)
    ->    ack(ACK=y+1)

    挥手过程：
    ->    fin(SYN=x)
    <-    ack(ACK=x+1)
    <-    fin(SYN=y)
    ->    ack(ACK=y+1)    

```
5. HTTP的状态码有那些？301和302的区别？401和403的区别？502和504的区别？
```
    1xx:
        100: 继续
        101: 切换协议（比如websocket）
    
    2xx：
        200: 成功
        206: 部分信息
    3xx：
        301: 永久移动
        302：临时移动
        304: 文件未修改
        307: 和302相同，但是会使用get来代替post
    4xx：
        400: 请求方法不正确
        401: 未认证
        403: 权限不够
        404: 未找到
    5xx：
        500: 服务器内部错误
        502: 服务器作为网关或代理，从上游服务器收到无效应答
        504: 服务器作为网关或代理，从上游服务器接收应答超时
        505: 请求的HTTP协议版本不支持

```

6. Cookie和Session的区别？
```
    Cookie：服务器在客户端上存储的小段文本，并随着每一个请求发送至同一个服务器。cookie的内容包括名，值，过期时间，路径和域。默认过期时间是浏览器会话期间。
    Session：服务器利用散列表来保存Session信息。
    区别：
        1. 都是保存用户状态的技术
        2. Cookie一般用来存放ASCII，而Session可以用来存放二进制信息。
        3. 隐私策略不同：Cookie存放在客户端，客户端的某些程序能够读和写Cookie；而Session放在服务端，对于客户端是透明的，更加安全。
        4. 服务器压力不同：如果用户量特别多的化， 会给服务器增加负担。
        5. Session既可以通过在URL中添加SessionID的方式实现，也可以通过在Cookie中添加SessionID这一项。
        6. 单个Cookie在客户端的限制是3K，而Session没有限制。

```
7. TCP和UDP的区别？
```
    1. TCP是有状态的，UDP没有状态
    2. TCP是可靠的，UDP不可靠
    3. TCP报文比较大，UDP比较小
    4. TCP是面向字节流的，UDP是面向报文的。
```
8. TIME-WAIT的作用？
```
    1. 保证对方能够收到ACK报文，正确断开连接
    2. 避免新老连接混在一起，影响新连接的建立。
```
9. CLOSE-WAIT太多怎么办？
```
    1. 查代码，实现有问题。FIN包没有发送出去，可能是由于socket没有正常关闭。
```
10. 输入 ping IP 后，在发包之前会发生什么？
```
    1. 查询路由表，决定从哪个网卡出去。
    2. 判断是否在局域网内
        2.1 如果在局域网内，查询arp表，如果查到了，直接发出去；否则向局域网内发arp广播查询该IP地址对应的MAC地址，查到后缓存该IP-MAC対，并发出去。
        2.2 如果不在局域网内，填入网关的MAC地址发出去。
```
11. 建立一个socket要经过哪些步骤？
```
    1. 服务器和客户端分别调用 int socket(int domain, int type, int protocol); 建立一个socket.
    2. 服务器和客户端分别调用 int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen); 将socket 绑定到本地的一个地址上面来。
    3. 服务器上用 int listen(int sockfd, int backlog); 开启socket监听,等待客户端的连接
    4. 客户端上用 int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen); 连接服务器
    5. 服务器上用 int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen); 建立起一个socket连接
    6. 服务器和客户端分别调用 ssize_t read(int fd, void *buf, size_t count); ssize_t write(int fd, const void *buf, size_t count); 来进行通信。
    7. 服务器和客户端均可以调用 int close(int fd); 来关闭连接
```
12. TLS的握手过程详细说一下？
```
    TLS1.2 完整握手过程：
      Client                                               Server

      ClientHello                  -------->
                                                      ServerHello
                                                     Certificate*
                                               ServerKeyExchange*
                                              CertificateRequest*
                                   <--------      ServerHelloDone
      Certificate*
      ClientKeyExchange
      CertificateVerify*
      [ChangeCipherSpec]
      Finished                     -------->
                                               [ChangeCipherSpec]
                                   <--------             Finished
      Application Data             <------->     Application Data

             Figure 1.  Message flow for a full handshake

    1. ClientHello 和 ServerHello 用来定义协议版本，Session ID， 算法套件，压缩方法，还有两个随机数。
    2. 密钥交换需要Server Certificate, ServerKeyExchange, Client Certificate, ClientKeyExchange四个消息。
    3. 第一个被加密的信息是Client Finished。
    4. SessionID 在ServerHello 中。
    5. DHE能够提供FS (Forward Secrey) 前向安全，RSA不能够
    6. APLN存在ClientHello消息中，用来告诉服务器它所加密的上层协议类型。
    7. SNI存在ClientHello消息中，用来解决一个IP地址上多个域名的问题。
    8. Session重用通过Session ID和 Session Ticket的方式解决

    TLS1.2 恢复握手过程：
      Client                                                Server

      ClientHello                   -------->
                                                       ServerHello
                                                [ChangeCipherSpec]
                                    <--------             Finished
      [ChangeCipherSpec]
      Finished                      -------->
      Application Data              <------->     Application Data

          Figure 2.  Message flow for an abbreviated handshake
    
    1. ClientHello 中存放着之前的Session ID信息。
    2. 此时必须要发送ChangeCipherSpec消息


    TLS1.3 握手过程：
       Client                                           Server

Key  ^ ClientHello
Exch | + key_share*
     | + signature_algorithms*
     | + psk_key_exchange_modes*
     v + pre_shared_key*       -------->
                                                  ServerHello  ^ Key
                                                 + key_share*  | Exch
                                            + pre_shared_key*  v
                                        {EncryptedExtensions}  ^  Server
                                        {CertificateRequest*}  v  Params
                                               {Certificate*}  ^
                                         {CertificateVerify*}  | Auth
                                                   {Finished}  v
                               <--------  [Application Data*]
     ^ {Certificate*}
Auth | {CertificateVerify*}
     v {Finished}              -------->
       [Application Data]      <------->  [Application Data]

              +  Indicates noteworthy extensions sent in the
                 previously noted message.

              *  Indicates optional or situation-dependent
                 messages/extensions that are not always sent.

              {} Indicates messages protected using keys
                 derived from a [sender]_handshake_traffic_secret.

              [] Indicates messages protected using keys
                 derived from [sender]_application_traffic_secret_N.

               Figure 1: Message Flow for Full TLS Handshake



         Client                                               Server

         ClientHello
         + early_data
         + key_share*
         + psk_key_exchange_modes
         + pre_shared_key
         (Application Data*)     -------->
                                                         ServerHello
                                                    + pre_shared_key
                                                        + key_share*
                                               {EncryptedExtensions}
                                                       + early_data*
                                                          {Finished}
                                 <--------       [Application Data*]
         (EndOfEarlyData)
         {Finished}              -------->
         [Application Data]      <------->        [Application Data]

               Figure 4: Message Flow for a 0-RTT Handshake
    1. TLS1.2 需要2个rtt才能完成握手，TLS1.3只需要1个rtt就能完成握手。
    2. 移出了不安全的算法。只有DHE了。
    3. TLS1.2 需要1个rtt来完成Session重用，TLS1.3 的session重用只需要0个rtt
```


数据库：
1. Redis的数据结构有哪几种，它们的底层实现是什么？
2. 聚簇索引和非聚簇索引介绍一下？
```
    1. 两者的区别在于叶子节点是否存放了一整行的数据
    2. InnoDB主键使用聚簇索引，二级索引使用的是非聚簇索引，MyISAM使用的都是非聚簇索引。
    3. 聚簇索引查找目标数据时，理论上比非聚簇索引更快
    4. 聚簇索引插入很慢，需要遍历所有节点，但是由于叶子节点上面的数据很大，会因此付出IO代价。
    5. 一张表只允许创建一个聚簇索引。主键会默认创建聚簇索引。
```
3. B+树的结构介绍一下？
```
    1. B+树基于B树和叶子节点顺序访问指针进行实现，它具有B树的平衡性并能够通过顺序访问指针来提高区间查询的性能。
    2. 在B+树中，叶子节点的Key从左向右非递减排序。
    3. B+树需要通过分裂，合并，旋转的方式来维护平衡性。
    4. 与红黑树相比, 平衡树查找的时间复杂度与树高有关，而B+树的出度大，高度低，因此查找次数更少。而且区间查找更快速。
    5. 与B树相比，非叶子节点不存放值。因此，依次IO操作可以读入更多的节点。加速查找。而且区间查找更快速。
```
4. Hash冲突的解决办法？
```
    1. 开放地址法
    2. 再哈希法
    3. 链地址法
    4. 建立公共缓冲区
```
5. Redis 持久化有哪几种方式？
```
    1. RDB方式：默认开启，Redis会按照配置的指定时间将内存中的数据写入道磁盘上，创建一个dump.rdb文件，Redis启动时再恢复到内存。
       Redis会fork出一个子进程，将当前父进程的数据库拷贝到子进程的内存中来，然后由子进程负责写入道临时文件，持久化的过程结束了，再用
       这个临时文件替换掉上次的快照文件成为新的快照。
    2. AOF方式：以日志的形式记录每条写操作，不记录读操作。Redis启动时会根据日志内容从头到尾的执行一遍，完成持久化。
       因为采用追加的方式，会使的文件越来越大，针对这个问题，新增了重写机制，当日志文件大到一定程度的时候，会fork出一条新进程遍历父进程
       内存中的数据，每条记录对应一条set语句，写入道临时文件中，之后在替换原来的aof文件。默认触发条件是日志文件大小翻倍，并且大于64M。
```

6. Redis常见性能及解决方案？
```
    1. Master 最好不要做持久化工作，让Slave做。
    2. 如果数据比较重要，某个Slave开启AOF备份，策略设置为每秒同步一次。
    3. 为了主从复制的速度和连接的稳定性，Master和Slave最好在同一个局域网内。
    4. 主从复制不要采用图状结构，采用链状结构更稳定。方便解决单点故障。
```

7. Redis有哪几种淘汰旧数据的方案？
```
    1. volatile-ttl：从设置过期时间的数据集中选出最早要过期的
    2. volatile-lru: 从设置过期时间的数据集中选出最近最少使用的
    3. volatile-random: 从设置过期时间的数据集中随机选择一个
    4. allkeys-lru: 从整个数据集中选出最近最少使用的
    5. allkeys-random: 从整个数据集中随机选择一个
    6. noeviction: 不淘汰。
```

8. Redis 为什么是单线程的？
```
    1. 多线程涉及到锁，实现复杂。
    2. Redis的瓶颈在于内存和带宽，而不是CPU
    3. 虽然单进程无法发挥多核CPU的性能，但是可以通过在一个机器上开多个Redis来解决。
```

9. Redis 哨兵和复制？
```
    1. Sentinel可以管理多个Redis服务器，提供了监控，提醒，和自动的故障转移功能。
    2. Replication 负责让一个Redis服务器可以管理多个备份服务器。
```

10. Redis 哈希槽是什么？
```
    1. 当向Redis cluster中加入一个key，会根据crc16(key) mod 16384计算这个key应该放到哪个hash slot中，
       一个hash slot中会有很多的key和value。可以理解是表的分区。
    2. 便于动态的增加和删除节点，不需要停掉服务。
    3. key通过hash算法计算出应该放到哪个hash slot中，然后更具内存表来判断这个slot应该在哪个物理节点上。
    4. 哈希槽是16384（2^14）的原因：
        4.1 2^16个槽心跳信息达到8K，而2^14次方只有2K。
        4.2 crc16 対 2^14 取模，会使的key能够分布的很均匀。
    5. Redis集群最大节点数量也是16384 (2^14)个。

```


算法：
1. 基本排序中，哪些是稳定的，哪些是不稳定的？
2. 如何对一个20GB的大文件进行排序？
3. 如何判断两个无环单链表是否有交叉点？
4. 如何判断一个单链表有没有环，并找出交叉点？
5. 手写一个快速排序？
6. 给一个二叉树，判断是否是二叉搜索树？